<html>
<head>
<title>Math - Calculus</title>
<link rel="stylesheet" type="text/css" href="style.css">
<style></style>
</head>

<body>

<br id="differentiation"/>
<h1>Differentiation</h1>

<p><b>diff( <i>f</i>, <i>x</i> )</b> &mdash; numerical derivative of a real or complex function at <i>x</i></p>

<p><b>diff( <i>f</i>, <i>x</i>, <i>n</i> )</b> &mdash; <i>n</i>th-order numerical derivative of a real or complex function at <i>x</i></p>

<p><b>D( <i>f</i>, <i>x</i> )</b> &mdash; numerical derivative of a real or complex function at <i>x</i></p>

<p><b>D( <i>f</i>, <i>x</i>, <i>n</i> )</b> &mdash; <i>n</i>th-order numerical derivative of a real or complex function at <i>x</i></p>

<p><b>taylorSeries( <i>f</i>, <i>x</i><sub>0</sub> )</b> &mdash; numerical Taylor series of five terms of a real or complex function around <i>x</i><sub>0</sub> returned as a function</p>

<p><b>taylorSeries( <i>f</i>, <i>x</i><sub>0</sub>, terms )</b> &mdash; numerical Taylor series of an arbitrary number of terms of a real or complex function around <i>x</i><sub>0</sub> returned as a function</p>

<p><b>gradient( <i>f</i>, point )</b> &mdash; numerical gradient of a real or complex function of multiple variables at the correspondingly dimensioned point</p>

<p><b>findExtremum( <i>f</i>, point )</b> &mdash; numerical minimum of a real function of multiple variables by gradient descent at the correspondingly dimensioned point</p>

<p><b>findExtremum( <i>f</i>, point, { findMaximum: true } )</b> &mdash; numerical maximum of a real function of multiple variables by gradient ascent at the correspondingly dimensioned point</p>

<br id="integration"/>
<h1>Integration</h1>

<p><b>integrate( <i>f</i>, [<i>a</i>,<i>b</i>] )</b> &mdash; numerical integral of a real or complex function on the interval [<i>a</i>,<i>b</i>] by an adaptive Simpson algorithm</p>

<p><b>integrate( <i>f</i>, [<i>a</i>,<i>b</i>], options )</b> &mdash; numerical integral of a real or complex function on the interval [<i>a</i>,<i>b</i>]; options include</p>

<table style="margin-left: 1in"><tr><td style="width: 1.5in">
  <code>method</code></td><td>one of <nobr><code>'euler-maclaurin'</code></nobr>, <code>'romberg'</code>, <nobr><code>'adaptive-simpson'</code></nobr>, <nobr><code>'tanh-sinh'</code></nobr> or <code>'gaussian'</code>; default <nobr><code>'adaptive-simpson'</code></nobr>
</td></tr><tr><td>
  <code>tolerance</code></td><td>default 10<sup>&minus;10</sup>
</td></tr><tr><td>
  <code>avoidEndpoints</code></td><td>set to <code>true</code> to displace endpoints by <code>tolerance</code>
</td></tr></table>

<p><b>discreteIntegral( values, step )</b> &mdash; numerical integral over discrete real values separated by step using Euler-Maclaurin summation</p>

<p><b>summation( <i>f</i>, [<i>a</i>,<i>b</i>] )</b> &mdash; discrete summation of real or complex function values from <i>a</i> to <i>b</i> inclusive in integer steps</p>

<br id="interpolation"/>
<h1>Interpolation</h1>

<p><b>polynomial( <i>x</i>, coefficients )</b> &mdash; value of polynomial with real or complex coefficients at <i>x</i> by Horner&rsquo;s rule with the coefficient of the highest power first</p>

<p><b>polynomial( <i>x</i>, coefficients, <code>true</code> )</b> &mdash; value of polynomial with real or complex coefficients and its derivative at <i>x</i> by Horner&rsquo;s rule returned as <nobr><code>{ polynomial: polynomial, derivative: derivative }</code></nobr></p>

<p><b>partialBell( <i>n</i>, <i>k</i>, arguments )</b> &mdash; partial Bell polynomial with integer indices <i>n</i> and <i>k</i> and an array of length <i>n</i>&minus;<i>k</i>+1 of real arguments</p>

<p><b>findRoot( <i>f</i>, [<i>a</i>,<i>b</i>] )</b> &mdash; numerical root of a real function on the interval [<i>a</i>,<i>b</i>] by bisection</p>

<p><b>findRoot( <i>f</i>, <i>a</i> )</b> &mdash; numerical root of a real or complex function starting from <i>a</i> by Newton&rsquo;s method</p>

<p><b>findRoots( functions, point )</b> &mdash; numerical roots of an array of real functions starting from the correspondingly dimensioned point by Newton&rsquo;s method</p>

<p><b>spline( points )</b> &mdash; interpolating cubic spline over the array of two-dimensional points returned as a function</p>

<p><b>spline( points, value )</b> &mdash; interpolating cubic spline over the array of two-dimensional points with a value of <code>'function'</code>, <code>'derivative'</code> or <code>'integral'</code> returned as a function</p>

<br id="diffeq"/>
<h1>Differential Equations</h1>

<p><b>ode( <i>f</i>, <i>y</i><sub>0</sub>, [<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>] )</b> &mdash; numerical solution of the system <i>dy</i>/<i>dx</i>&nbsp;=&nbsp;<i>f</i>(<i>x</i>,<i>y</i>), <i>y</i>(<i>x</i><sub>0</sub>)&nbsp;=&nbsp;<i>y</i><sub>0</sub> on the specified interval. The function and initial condition should be vectorized for higher-order systems. The solution is returned as an array of arrays of data points, with the independent variable as the first item in each data point array.</p>

<p><b>ode( <i>f</i>, <i>y</i><sub>0</sub>, [<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>], step, method )</b> &mdash; numerical solution of the system <i>dy</i>/<i>dx</i>&nbsp;=&nbsp;<i>f</i>(<i>x</i>,<i>y</i>), <i>y</i>(<i>x</i><sub>0</sub>)&nbsp;=&nbsp;<i>y</i><sub>0</sub> on the specified interval with specified step size and a method of <code>'euler'</code> or <nobr><code>'runge-kutta'</code></nobr>. The function and initial condition should be vectorized for higher-order systems. The solution is returned as an array of arrays of data points, with the independent variable as the first item in each data point array.</p>

<br id="transformation"/>
<h1>Transformation</h1>

<p><b>fourierSinCoefficient( <i>f</i>, <i>n</i> )</b> &mdash; Fourier sine coefficient of index <i>n</i> of a continuous real function on the interval [0,2&pi;]</p>

<p><b>fourierSinCoefficient( <i>f</i>, <i>n</i>, period )</b> &mdash; Fourier sine coefficient of index <i>n</i> of a continuous real function on the interval [0,period]</p>

<p><b>fourierSinCoefficient( points, <i>n</i> )</b> &mdash; Fourier sine coefficient of index <i>n</i> of an array of discrete two-dimensional points</p>

<p><b>fourierCosCoefficient( <i>f</i>, <i>n</i> )</b> &mdash; Fourier cosine coefficient of index <i>n</i> of a continuous real function on the interval [0,2&pi;]</p>

<p><b>fourierCosCoefficient( <i>f</i>, <i>n</i>, period )</b> &mdash; Fourier cosine coefficient of index <i>n</i> of a continuous real function on the interval [0,period]</p>

<p><b>fourierCosCoefficient( points, <i>n</i> )</b> &mdash; Fourier cosine coefficient of index <i>n</i> of an array of discrete two-dimensional points</p>

</body>
</html>
