<html>
<head>
<title>Math - Calculus</title>
<link rel="stylesheet" type="text/css" href="style.css">
<style></style>
</head>

<body>

<br id="differentiation"/>
<h1>Differentiation</h1>

<p><b>diff( <i>f</i>, <i>x</i> )</b> &mdash; numerical derivative of a real or complex function at <i>x</i></p>

<p><b>diff( <i>f</i>, <i>x</i>, <i>n</i> )</b> &mdash; <i>n</i>th-order numerical derivative of a real or complex function at <i>x</i></p>

<p><b>diff( <i>f</i>, <i>x</i>, <i>n</i>, options )</b> &mdash; <i>n</i>th-order numerical derivative of a real or complex function at <i>x</i>. Options for this dictionary argument include</p>

<table style="margin-left: 1in"><tr><td style="width: 1.5in; vertical-align: top">
  <code>method</code></td><td>either <code>'naive'</code> or <code>'ridders'</code>, default <code>'ridders'</code>
</td></tr><tr><td>
  <code>epsilon</code></td><td>sets initial step, default 10<sup>&minus;5</sup>
</td></tr></table>

<p><b>D( <i>f</i>, <i>x</i> )</b> &mdash; numerical derivative of a real or complex function at <i>x</i></p>

<p><b>D( <i>f</i>, <i>x</i>, <i>n</i> )</b> &mdash; <i>n</i>th-order numerical derivative of a real or complex function at <i>x</i></p>

<br/><p><b>taylorSeries( <i>f</i>, <i>x</i><sub>0</sub> )</b> &mdash; numerical Taylor series of five terms of a real or complex function around <i>x</i><sub>0</sub> returned as a function</p>

<p><b>taylorSeries( <i>f</i>, <i>x</i><sub>0</sub>, terms )</b> &mdash; numerical Taylor series of an arbitrary number of terms of a real or complex function around <i>x</i><sub>0</sub> returned as a function</p>

<p><b>gradient( <i>f</i>, point )</b> &mdash; numerical gradient of a real or complex function of multiple variables at the correspondingly dimensioned point</p>

<p><b>findExtremum( <i>f</i>, point )</b> &mdash; numerical minimum of a real function of multiple variables by gradient descent at the correspondingly dimensioned point</p>

<p><b>findExtremum( <i>f</i>, point, { findMaximum: true } )</b> &mdash; numerical maximum of a real function of multiple variables by gradient ascent at the correspondingly dimensioned point</p>

<br id="integration"/>
<h1>Integration</h1>

<p><b>integrate( <i>f</i>, [<i>a</i>,<i>b</i>] )</b> &mdash; numerical integral of a real or complex function on the interval [<i>a</i>,<i>b</i>] by an adaptive Simpson algorithm</p>

<p><b>integrate( <i>f</i>, [<i>a</i>,<i>b</i>], options )</b> &mdash; numerical integral of a real or complex function on the interval [<i>a</i>,<i>b</i>]. Options for this dictionary argument include</p>

<table style="margin-left: 1in"><tr><td style="width: 1.5in; vertical-align: top">
  <code>method</code></td><td>one of <nobr><code>'euler-maclaurin'</code></nobr>, <code>'romberg'</code>, <nobr><code>'adaptive-simpson'</code></nobr>, <nobr><code>'tanh-sinh'</code></nobr> or <code>'gaussian'</code>, default <nobr><code>'adaptive-simpson'</code></nobr>
</td></tr><tr><td>
  <code>tolerance</code></td><td>default 10<sup>&minus;10</sup>
</td></tr><tr><td>
  <code>avoidEndpoints</code></td><td>set to <code>true</code> to displace endpoints by <code>tolerance</code>
</td></tr></table>

<p><b>discreteIntegral( values, step )</b> &mdash; numerical integral over discrete real values separated by step using Euler-Maclaurin summation</p>

<p><b>summation( <i>f</i>, [<i>a</i>,<i>b</i>] )</b> &mdash; discrete summation of real or complex function values from <i>a</i> to <i>b</i> inclusive by unit step</p>

<p><b>summation( <i>f</i>, [<i>a</i>,<i>b</i>,step] )</b> &mdash; discrete summation of real or complex function values from <i>a</i> to <i>b</i> inclusive by arbitrary step</p>

<br id="interpolation"/>
<h1>Interpolation</h1>

<p><b>polynomial( <i>x</i>, coefficients )</b> &mdash; value of polynomial with real or complex coefficients at <i>x</i> by Horner&rsquo;s rule with the coefficient of the highest power first</p>

<p><b>polynomial( <i>x</i>, coefficients, options )</b> &mdash; value of polynomial with real or complex coefficients at <i>x</i> by Horner&rsquo;s rule. Options for this dictionary argument include</p>

<table style="margin-left: 1in"><tr><td style="width: 1.5in; vertical-align: top">
  <code>derivative</code></td><td>return both the value of the polynomial and its derivative as <nobr><code>{ polynomial: value, derivative: value }</code></nobr>
</td></tr><tr><td style="; vertical-align: top">
  <code>reverse</code></td><td>set to <code>true</code> to reverse the order of coefficients and make the lowest power first
</td></tr></table>

<p><b>partialBell( <i>n</i>, <i>k</i>, arguments )</b> &mdash; partial Bell polynomial with integer indices <i>n</i> and <i>k</i> and an array of length <i>n</i>&minus;<i>k</i>+1 of real arguments</p>

<br/><p><b>findRoot( <i>f</i>, [<i>a</i>,<i>b</i>] )</b> &mdash; numerical root of a real function on the interval [<i>a</i>,<i>b</i>] by bisection</p>

<p><b>findRoot( <i>f</i>, <i>a</i> )</b> &mdash; numerical root of a real or complex function starting from <i>a</i> by Newton&rsquo;s method</p>

<p><b>findRoot( functions, point )</b> &mdash; simultaneous numerical root of an array of real functions starting from the correspondingly dimensioned point by Newton&rsquo;s method</p>

<p>All three forms of this function can take a third <code>options</code> argument as a dictionary. The main option is <code>tolerance</code> with default 10<sup>&minus;10</sup>.</p>

<br/><p><b>spline( points )</b> &mdash; interpolating cubic spline over the array of two-dimensional points returned as a function</p>

<p><b>spline( points, value )</b> &mdash; interpolating cubic spline over the array of two-dimensional points with a value of <code>'function'</code>, <code>'derivative'</code> or <code>'integral'</code> returned as a function</p>

<p><b>padeApproximant( coefficients, <i>n</i>, <i>d</i> )</b> &mdash; [<i>n</i>/<i>d</i>] Pad&eacute; approximant for Taylor coefficients centered at the origin returned as a pair of coefficient arrays <code>{ N: N, D: D }</code></p>

<p><b>padeApproximant( coefficients, <i>n</i>, <i>d</i>, center )</b> &mdash; [<i>n</i>/<i>d</i>] Pad&eacute; approximant for Taylor coefficients centered at the center returned as a pair of coefficient arrays <code>{ N: N, D: D }</code></p>

<p><b>padeApproximant( <i>f</i>, <i>n</i>, <i>d</i> )</b> &mdash; [<i>n</i>/<i>d</i>] Pad&eacute; approximant using numerical derivatives of a real function centered at the origin returned as a pair of coefficient arrays <code>{ N: N, D: D }</code></p>

<p><b>padeApproximant( <i>f</i>, <i>n</i>, <i>d</i>, center )</b> &mdash; [<i>n</i>/<i>d</i>] Pad&eacute; approximant using numerical derivatives of a real function centered at the center returned as a pair of coefficient arrays <code>{ N: N, D: D }</code></p>

<br id="diffeq"/>
<h1>Differential Equations</h1>

<p><b>ode( <i>f</i>, <i>y</i><sub>0</sub>, [<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>] )</b> &mdash; numerical solution of the real or complex system <i>dy</i>/<i>dx</i>&nbsp;=&nbsp;<i>f</i>(<i>x</i>,<i>y</i>), <i>y</i>(<i>x</i><sub>0</sub>)&nbsp;=&nbsp;<i>y</i><sub>0</sub> on the specified interval.</p>

<p><b>ode( <i>f</i>, <i>y</i><sub>0</sub>, [<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>], step, method )</b> &mdash; numerical solution of the real or complex system <i>dy</i>/<i>dx</i>&nbsp;=&nbsp;<i>f</i>(<i>x</i>,<i>y</i>), <i>y</i>(<i>x</i><sub>0</sub>)&nbsp;=&nbsp;<i>y</i><sub>0</sub> on the specified interval with specified step size and a method of <code>'euler'</code> or <nobr><code>'runge-kutta'</code></nobr>.</p>

<p>For higher-order systems, the function and initial conditions should be vectorized, <i>i.e.</i> the function should return an array of values the same length as the intial conditions array. The solution is returned as an array of arrays of data points, with the independent variable as the first item in each data point array.</p>

<br id="transformation"/>
<h1>Transformation</h1>

<p><b>fourierSinCoefficient( <i>f</i>, <i>n</i> )</b> &mdash; Fourier sine coefficient of index <i>n</i> of a continuous real function on the interval [0,2&pi;]</p>

<p><b>fourierSinCoefficient( <i>f</i>, <i>n</i>, period )</b> &mdash; Fourier sine coefficient of index <i>n</i> of a continuous real function on the interval [0,period]</p>

<p><b>fourierSinCoefficient( points, <i>n</i> )</b> &mdash; Fourier sine coefficient of index <i>n</i> of an array of discrete two-dimensional points</p>

<p><b>fourierCosCoefficient( <i>f</i>, <i>n</i> )</b> &mdash; Fourier cosine coefficient of index <i>n</i> of a continuous real function on the interval [0,2&pi;]</p>

<p><b>fourierCosCoefficient( <i>f</i>, <i>n</i>, period )</b> &mdash; Fourier cosine coefficient of index <i>n</i> of a continuous real function on the interval [0,period]</p>

<p><b>fourierCosCoefficient( points, <i>n</i> )</b> &mdash; Fourier cosine coefficient of index <i>n</i> of an array of discrete two-dimensional points</p>

</body>
</html>
